<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Keegan Campbell | Go Allocators</title>
  <meta name="description" content="This is the personal site of Keegan Campbell.
">

  

  <link rel="shortcut icon" href="https://kfcampbell.com/assets/img/favicon.ico">

  <link rel="stylesheet" href="https://kfcampbell.com/assets/css/main.css">
  <link rel="canonical" href="https://kfcampbell.com/blog/2020/go-allocators/">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    
    <span class="site-title">
        
        <strong>Keegan</strong> Campbell
    </span>
    

    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

      <div class="trigger">
        <!-- About -->
        <a class="page-link" href="https://kfcampbell.com/">about</a>

        <!-- Blog -->
        <a class="page-link" href="https://kfcampbell.com/blog/">blog</a>

        <!-- Pages -->
        
          
        
          
        
          
        
          
        

        <!-- CV link -->
        <!-- <a class="page-link" href="https://kfcampbell.com/assets/pdf/CV.pdf">vitae</a> -->

      </div>
    </nav>

  </div>

</header>



    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Go Allocators</h1>
    <p class="post-meta">June 23, 2020</p>
  </header>

  <article class="post-content">
    <p>I was driving and listening to <a href="https://changelog.com/gotime/100">episode 100 of the Go Time podcast</a> the other day, and heard something from language creator Rob Pike that gave me pause: there’s actually two allocators in Go, <code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">make</code>.</p>

<p>In writing day-to-day Go, most people don’t use the <code class="language-plaintext highlighter-rouge">new</code> keyword. In fact, I didn’t know that it even existed (though it’s very common in other languages)! The figuratively first thing I did when I got home was sit down at my computer to test it out. First, let’s re-familiarize ourselves with the normal <code class="language-plaintext highlighter-rouge">&amp;</code> syntax:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">ContrivedExample</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Text</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ex</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ContrivedExample</span><span class="p">{</span>
		<span class="n">Text</span><span class="o">:</span> <span class="s">"This feels familiar."</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">Text</span><span class="p">)</span> <span class="c">// This feels familiar.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That’s not too spooky. We can switch it up a bit so that we initialize the object without providing a value for <code class="language-plaintext highlighter-rouge">Text</code>, and then set that later:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">ContrivedExample</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Text</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ex</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ContrivedExample</span><span class="p">{}</span>
	<span class="n">ex</span><span class="o">.</span><span class="n">Text</span> <span class="o">=</span> <span class="s">"This feels familiar."</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">Text</span><span class="p">)</span> <span class="c">// This feels familiar.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now let’s take the <code class="language-plaintext highlighter-rouge">new</code> keyword for a spin:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">ContrivedExample</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Text</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ex</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">ContrivedExample</span><span class="p">)</span>
	<span class="n">ex</span><span class="o">.</span><span class="n">Text</span> <span class="o">=</span> <span class="s">"What the hell is really going on?"</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">Text</span><span class="p">)</span> <span class="c">// What the hell is really going on?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That’s crazy! It looks weird to me to see that in a working Go program. Also it might be a good way to annoy coworkers in your next code review.</p>

<p>Go uses the <code class="language-plaintext highlighter-rouge">new</code> keyword (or its suspiciously sugary syntax shortcut, <code class="language-plaintext highlighter-rouge">&amp;</code>) for <em>direct</em> memory allocation: primitives, structs, any type you define.</p>

<p>So let’s take a peek next at <code class="language-plaintext highlighter-rouge">make</code> next.</p>

<p>Go uses the <code class="language-plaintext highlighter-rouge">make</code> keyword for three certain types that require Go magic to work with easily:</p>

<p>If we <a href="https://github.com/golang/go/blob/7b872b6d955d3e749ea62dbfced68ab5c61eae91/src/builtin/builtin.go#L172">read the docs</a> in the source code of the allocator, we can see this described:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// The make built-in function allocates and initializes an object of type</span>
<span class="c">// slice, map, or chan (only). Like new, the first argument is a type, not a</span>
<span class="c">// value. Unlike new, make's return type is the same as the type of its</span>
<span class="c">// argument, not a pointer to it. </span>
</code></pre></div></div>

<p>What happens if we try to use the <code class="language-plaintext highlighter-rouge">new</code> keyword to instantiate a slice, for example? Well, the compiler gets angry:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ex</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span> <span class="c">// would print *[]int if this compiled</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="m">42</span><span class="p">)</span> <span class="c">// invalid argument: ex (variable of type *[]int) is not a slice</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ex</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="c">// invalid operation: cannot index ex (variable of type *[]int)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Aha! We’re getting a little closer: it turns out that <code class="language-plaintext highlighter-rouge">new</code> returns a <em>pointer</em> to whatever type you want to create.</p>

<p>But that same code works just fine when we try it with <code class="language-plaintext highlighter-rouge">make</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ex</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span> <span class="c">// int[]</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="m">42</span><span class="p">)</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ex</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="c">// 42</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And like the docs state, <code class="language-plaintext highlighter-rouge">make</code> returns a slice, not a pointer to it. Why?</p>

<p>A pointer is only a location to a specific location in memory. It’s as close as you can get to the direct memory location of your variable.</p>

<p>Slices, maps, and channels need a little bit more magic to work correctly.</p>

<p>Incidentally, <em>slicing</em> an array returns a slice type as well:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ex</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">50</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span> <span class="c">// []int</span>

	<span class="n">why</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">([</span><span class="m">100</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">why</span><span class="p">)</span> <span class="c">// *[100]int</span>

	<span class="n">zee</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">([</span><span class="m">100</span><span class="p">]</span><span class="kt">int</span><span class="p">)[</span><span class="m">0</span><span class="o">:</span><span class="m">50</span><span class="p">]</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">zee</span><span class="p">)</span> <span class="c">// []int</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">why</code>’s type <code class="language-plaintext highlighter-rouge">*[100]int</code> reflects both a pointer to a specific location and not the object itself, and a given size for the length of the (fixed) array.</p>

<p>Anyways, we were looking at the difference between <code class="language-plaintext highlighter-rouge">make</code> and <code class="language-plaintext highlighter-rouge">new</code>, so let’s read some source code. <a href="https://github.com/golang/go/blob/master/src/runtime/malloc.go#L1192">new</a> is implemented like so:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// implementation of new builtin</span>
<span class="c">// compiler (both frontend and SSA backend) knows the signature</span>
<span class="c">// of this function</span>
<span class="k">func</span> <span class="n">newobject</span><span class="p">(</span><span class="n">typ</span> <span class="o">*</span><span class="n">_type</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">mallocgc</span><span class="p">(</span><span class="n">typ</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="no">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For our purposes, we’re not very concerned with the particulars of <code class="language-plaintext highlighter-rouge">mallocgc()</code>; it’s enough to know that <code class="language-plaintext highlighter-rouge">new</code> returns an <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">make</code> source, however, is split up into three pieces. The Go compiler creates calls to either <a href="https://github.com/golang/go/blob/master/src/runtime/slice.go#L83">makeslice()</a>, <a href="https://github.com/golang/go/blob/master/src/runtime/map.go#L303">makemap()</a>, or <a href="https://github.com/golang/go/blob/master/src/runtime/chan.go#L71">makechan()</a> depending on what developer requires.</p>

<p>Note that due to optimizations, these functions may not be called <em>exactly</em>. For example, there’s a <a href="https://github.com/golang/go/blob/master/src/runtime/map.go#L292">makemap_small()</a> function called under certain conditions instead of <code class="language-plaintext highlighter-rouge">makemap</code>.</p>

<p>However, eagle-eyed readers will notice that <code class="language-plaintext highlighter-rouge">makeslice()</code>, for example, <em>also</em> returns an <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>.</p>

<p>What’s going on here? Earlier we said that calls to <code class="language-plaintext highlighter-rouge">make()</code> returned a type, not a pointer to a type.</p>

<p>Well, <code class="language-plaintext highlighter-rouge">makeslice()</code> is called by other helper initialization code. This is the actual definition of what we think of as a <a href="https://github.com/golang/go/blob/master/src/runtime/slice.go#L13">slice</a>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">slice</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">array</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
	<span class="nb">len</span>   <span class="kt">int</span>
	<span class="nb">cap</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is known as the <em>slice header</em>. I wanted to make a little drawing, so here’s a brief explanation of each part:</p>

<p><img class="col three" src="/assets/img/slice_header.png" /></p>
<div class="col three caption">
    I'm sorry, I really tried to draw a decent row of blocks for that array. I'm not spatially gifted.
</div>
<p><br /></p>

<p>However, slice/map/channel internals are out of scope for this blog post. If I <a href="https://knowyourmeme.com/memes/feeling-cute-might-delete-later">feel cute later</a>, I might write another blog post on them, idk.</p>

<p>Is there a moral to this whole story? Not really, no.</p>

<p>Or maybe, there’s a couple of small ones, like “you should know Go has two allocators”, or “slices are made up of a pointer to an array, and integer values for length and capacity”, or “Keegan can’t draw to save his life”.</p>

<p>Regardless, I thought it was interesting and wanted to write about it. If you’ve made it this far, congratulations! I hope you learned something.</p>

<p>P.S. Throughout the entire length of this post, I’ve been trying to work in the language “Don’t hate, allocate” in a clever manner and I’ve failed to do so. If you can think of a better way to do it, please get at me <a href="https://twitter.com/keeganfcampbell">@keeganfcampbell</a> on Twitter.</p>

  </article>

  

</div>

      </div>
    </div>

    <footer>

  <div class="wrapper">
    &copy; Copyright 2020 Keegan Campbell.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.

    
  </div>

</footer>


    <!-- Load jQuery -->
<script src="//code.jquery.com/jquery-1.12.4.min.js"></script>

<!-- Load Common JS -->
<script src="https://kfcampbell.com/assets/js/common.js"></script>


<!-- Load KaTeX -->
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
<script src="https://kfcampbell.com/assets/js/katex.js"></script>




<!-- Include custom icon fonts -->
<link rel="stylesheet" href="https://kfcampbell.com/assets/css/fontawesome-all.min.css">
<link rel="stylesheet" href="https://kfcampbell.com/assets/css/academicons.min.css">




  </body>

</html>
